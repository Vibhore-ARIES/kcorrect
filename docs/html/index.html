<HTML>
<BODY>

<H1> Fitting Galaxy Spectral Energy Distributions </h1>
 
<p>
<a href="coeff_anim.default.500.gif">
<img src="coeff_anim.default.50.gif" width=50 height=50 border=0></a>
</p>

<p> Mike Blanton, Department of Physics, New York University </p>

<HR>

<h3> General Description</h3>

<p>
This web page documents a code written in C and IDL to calculate
spectral energy distributions and K-corrections. Standard format IDL
<a href="kcorrect_help.html"> documentation</a> exists. There is a <a
href="paper.ps"> paper</a> which describes the methods in
detail. Conditions of using the code released here are to cite this
paper and to specify the version tag (eg. v1_6) of the code used. (You
can check this in the IDL code using the <b>k_version</b> command).
</p>

<p> We document in detail here how to use the SED fits provided to
calculate K-corrections and SEDs for particular objects with
broad-band magnitude measurements. We do not document in detail how to
use the code to optimize the templates; the interested user can peruse
the comments in the code and/or contact the authors.  Note that
although this code has been written with SDSS in mind as its first
application, it has been written generally enough to be applied to
nearly any set of observations. To use observations outside the
optical range, it is probably necessary to fit the templates
again. </p>

<p> The code compiles into a shared object library callable by C, so
that people can incorporate the K-correction routines directly into
their code.  We also provide an interface to the identical library
through IDL. Users of Fortran might want to communicate with me about
how to accommodate their needs. It is possible in principle to link
the C libraries into code based on SM or TCL/Tk, and I would be
interested in helping interested parties to do this.</p>

<p> One can imagine using the results of this code to calculate the
evolution of the luminosity function, the distribution of galaxy
colors, as well as to develop galaxy classification algorithms. Or, to
estimate <a href="photoz.html"> photometric redshifts</a>.</p>

<h3> Obtaining the Code</h3>

The best way to obtain the code is to simply download the latest
version from this site. The tagged and released versions, from latest
to earliest, are:
<ul>
<li> <a href="kcorrect.v1_8.tar.gz"> kcorrect.v1_8.tar.gz</a>
</ul>
The earlier versions are only included so that you can reproduce old
results if you like.

It is also possible to export tagged versions from a public CVS
repository, using the CVS "export" feature, as follows (pirated this
description from spectro.princeton.edu):
<ul>
<li> Make sure your environment uses ssh to access CVS:
<pre>
CVS_RSH=ssh
export CVS_RSH
</pre>
<li> The first time you access the repository, create the .cvspass
file (run this in your home directory):
<pre>
cvs -d :pserver:anonymous@spectro.princeton.edu:/usr/local/cvsroot login
</pre>
When the above asks for a password, just hit Enter. 
<li> After this, you can just export any version you want:
<pre>
cvs -d :pserver:anonymous@spectro.princeton.edu:/usr/local/cvsroot export -r v1_8 kcorrect
</pre>
where you can replace v1_8 with whatever version you want.
</ul> 
Please export only based on revision tag, so that we can
track versions properly. 

<p>
It is also possible to CVS "checkout" the latest version of the
code. This is not recommended unless you want to become involved in
developing kcorrect (that is, if you will want to alter the code and
check it back in). Please <a href="mailto:mb144@nyu.edu"> contact
me</a> if you want to do this.
</p>

<h3> Compiling the Code</h3>

<p>
The code has been tested, and compiles and runs on a Red Hat 7.1
OS. Little experimentation with other operating systems has been
performed. Other Linux versions should port very easily, at least. 
In order to compile the code follow these directions:

<ul>
<li> First set the environmental variables (in, for example, bash):
<pre>
KCORRECT_DIR=/usr/local/kcorrect
IDL_PATH=$IDL_PATH:+$KCORRECT_DIR/pro
MAKE_FTNLIB="-lg2c"
KCORRECT_LD_LIB="/usr/lib"
PATH=$KCORRECT_DIR/bin:$PATH
export KCORRECT_LD_LIB MAKE_FTNLIB KCORRECT_DIR 
</pre>
These default settings may need to be changed on your system as
follows:
<ul>
<li>
<b>KCORRECT_DIR</b>: Simply substitute whatever directory you have
downloaded this product into. 
<li>
<b>MAKE_FTNLIB</b>: The library C needs to load in order to include
Fortran objects. As implied above, "-lg2c" is appropriate for Red Hat
Linux. 
<li>
<b>IDL_PATH</b>: Set only if you are using IDL
<li>
<b>KCORRECT_LD_LIB</b>: Should be a location which is in your
LD_LIBRARY_PATH, in which we will put the shared object library when
it is compiled. If you are trying to link this code in as a C library,
KCORRECT_LD_LIB has to be in LD_LIBRARY_PATH at run time. If you
don't have permission to write into /usr/lib, set
"LD_LIBRARY_PATH=$KCORRECT_LD_LIB:$LD_LIBARARY_PATH", so your code
knows where to find the kcorrect stuff.
</ul>
You probably want to put these settings in your .bashrc or .tcshrc
file.
<li> Type "evilmake -k". 
Then everything should compile, and IDL documentation should be
created. If you do not have IDL, the compile should complete what it
needs to complete and then give an error message that it can't make
the IDL docs. At this point, you should be able to open IDL and
start using the utilities described below. 
<li> Type "evilmake -k install". This will just copy libkcorrect.so to
the directory specified by KCORRECT_LD_LIB, so that writers of C code
can use it.  
</ul>

<p>
Note that the C codes "fit_coeffs.c" and "reconstruct_maggies.c" only depend
in the K-correction library; thus, you can use them as templates for
incorporating the K-correction code directly into your C code, as long
as you include the K-correction library. In fact, you would probably
put something like "fit_coeffs.c" into your code but include the
k_reconstruct_maggies() call directly inside to get the K-corrections.
</p>

<h3> The Basics</h3>

<p> We'll describe the basic idea before getting into exactly how to
use the code. To each set of five-band galaxy magnitudes I fit an SED
which is a linear combination of four templates. The four templates
have been optimized to minimize the residuals between the actual
galaxy magnitudes and the galaxy magnitudes reconstructed from the
galaxy SED fit.  The units of the fit spectra created are in ergs
cm^{-2} s^{-1} A^{-1}. The first coefficient of each object is the
number of ergs cm^{-2} s^{-1} within the range 3500 to 7500
Angstroms.</p>

<p> From the SED fit, one can reconstruct magnitudes corresponding to
observing the galaxy at an redshift within a large range (like 0 to
1). When you reconstruct magnitudes this way, it is best to ignore
those cases for which you are extrapolating the magnitude into a
region of the spectrum not directly observed (ie. for SDSS
observations you shouldn't trust
a reconstruction of the z=0.2 u-band based on z=0 observations). You
can use the reconstructions two ways: 
<ul>
<li> Use the reconstruction as the best estimate of that magnitude at
that redshift
<li> Estimate a K-correction to the actual magnitude as the ratio of the
reconstruction at the redshift desired to the
reconstruction at the actual redshift 
</ul>
This distinction matters very little if your reconstructions are
really good, as they are here.
</p>

<p>
The code is generally based on AB magnitudes or AB maggies. SDSS
luptitudes are AB quantities and for reasonably bright objects are
equivalent to AB magnitudes. "Maggies" are simply the linearized
version of AB magnitudes; that is, they are 10^{-0.4*mag} (the
conversion from luptitudes to maggies is a bit more complicated). </P>

<p> But you may still be wondering what I mean by an "AB"
magnitude. The AB system is designed such that a flat spectrum object
with f_nu = 3631 Jy = 3.631e-20 ergs cm^{-2} s^{-1} Hz^{-1} should
have every magnitude equal to zero. The beauty of the AB system is
that the uniform definition makes it convenient to synthesize AB
magnitudes from theory or models. The tragic flaw is that the quality
of the AB-ness of a system is very dependent on precise
spectrophotometry of standards and the carefulness of the calibrators,
since no objects have a flat spectrum. There is a tension between
these two needs --- similar to other tensions throughout astronomy
between making precise measurements and making interpretable ones.</p>

<h3> Using the IDL Code</h3>

The easiest interface to the code, if it is available to you, is the
IDL code. The detailed <a href="kcorrect_help.html"> documentation</a>
is available for all of the routines, but there is basically only
one you would usually use, which is <b>kcorrect</b>.

This routine performs the K-corrections on a 
set of magnitudes or maggies. It is called as follows:
<pre>
kcorrect, galaxy_mag, galaxy_magerr, galaxy_z, galaxy_mag0 [, $
    kcorrectz=, /maggies, version=, vpath=, rmatrix=, ematrix=, $
    zvals=, coeffs=, /sdssfix]
</pre>
If the "/maggies" flag is specified, galaxy_mag and galaxy_magerr are
in maggies; otherwise they are in magnitudes (see explanation
above). They should be [5,n] arrays. The reconstructed magnitudes are
returned in galaxy_mag0. If kcorrectz is set, all of the magnitudes
are reconstructed at the specified redshift; otherwise they are
reconstructed at the redshift of each object. Ignore version and vpath
UNLESS you want to specify your own set of templates. Finally, the
flag "/sdssfix" makes an attempt to analyze your magnitudes and fix
wacky magnitudes and errors to "reasonable" values for galaxies. This
flag is recommended for SDSS data.</p>

<p>
For example, one might do the following:
<pre>
kcorrect, [0., 2., 0.7, 0.3, 0.3], [0.02,0.02,0.02,0.02,0.02], $
    0.03, galaxy_mag0, kcorrectz=0.1
</pre>
which would take the set of magnitudes in the first argument, observed
for a galaxy at redshift 0.03, and reconstruct the magnitudes at z=0.1,
putting the result in galaxy_mag0.  </p>

<p> Please note that "kcorrect" uses a lot of overhead (2-3 seconds
worth), so if you can, use it on several thousand galaxies
simultaneously at least. If you use it on each object individually (as
in the example given above), you will be in trouble. If you truly
cannot avoid it, then specify the extra arguments rmatrix, ematrix,
and zvals. For example, if you run the following:
<pre>
kcorrect, [0., 2., 0.7, 0.3, 0.3], [0.02,0.02,0.02,0.02,0.02], $
    0.03, galaxy_mag0, kcorrectz=0.1, rmatrix=rmatrix, ematrix=ematrix, $
    zvals=zvals
kcorrect, [0., 1.7, 0.8, 0.2, 0.2], [0.02,0.02,0.02,0.02,0.02], $
    0.07, galaxy_mag0, kcorrectz=0.1, rmatrix=rmatrix, ematrix=ematrix, $
    zvals=zvals
</pre>
You will find that the second call takes far less time than the first,
because the temporary data stored in rmatrix, ematrix, and zvals will
not have to be regenerated.</p>

<h3> Using the Stand-Alone C Code</h3>

<p> The C code requires a bit more attention to use. If people say
they would use it if it were easier, I will improve it. In this
section, I will describe the stand-alone C programs which fit for the
coefficients and which calculate the reconstructed maggies. In the next
section, I will briefly describe how to use the libraries within your
own C code.  </p>

<p>
There are two stand-alone programs, <b>fit_coeffs</b> and
<b>reconstruct_maggies</b>. <b>fit_coeffs</b> uses the maggies in each band
to calculate the coefficients. <b>reconstruct_maggies</b> uses the list of
coefficients (as output by <b>fit_coeffs</b> to reconstruct the
magnitudes.
</p>

<p>
<b>fit_coeffs</b> is called in the following way:
<pre>
cat maggies.dat | fit_coeffs 
</pre>
where each line of "maggies.dat" has the form:
<pre>
z umaggies gmaggies rmaggies imaggies zmaggies uinvvar ginvvar rinvvar iinvvar zinvvar
</pre>
The "z" in the first column refers to redshift. All of the quantities
in this file are in maggies, as described above. So you have to
convert the luptitudes or magnitudes --- and the inverse variances ---
into maggies before calling this. (Note that the conversion
to the inverse variances from the maggies and the magnitude errors is
(maggies*0.4*ln(10)*magerr)^{-2}. </p>

<p> From the set of maggies and errors, the code calculates a set of
four coefficients which correspond to its guess about the nature of
the galaxy SED. The first coefficient measures the visual flux, as
described in the <a href="paper.ps"> paper</a>. This number is the
ergs/cm^2/s in the wavelength range 3500 to 7500 Angstroms. The other
coefficients are measures of the shape of the SED. The coefficients
are output to standard out in the form: 
<pre> 
coeff0 coeff1 coeff2 coeff3 z 
</pre> 
where the redshift z is included for reasons which
will be clear soon. </p>

<p> Once you have the coefficients, you can calculate the
reconstructed maggies at any redshift, using
<b>reconstruct_maggies</b>. The call to <b>reconstruct_maggies</b> is

<pre>
cat coeffs.dat | reconstruct_maggies [to_z]
</pre>
where coeffs.dat is in the same format as the output to
<b>fit_coeffs</b>:
<pre>
coeff0 coeff1 coeff2 coeff3 z
</pre>
If the optional parameter "to_z" is not specified, the maggies are
reconstructed at the redshift z of each object. If "to_z" is
specified, the maggies are all reconstructed to the specified
redshift. The output is in the form:
<pre>
u_rec g_rec r_rec i_rec z_rec 
</pre>
in the original maggy units.
</p>

<p> To summarize with an example, if you wanted to reconstruct a set
of maggies, all at redshift 0.1, you could call the code as follows:
<pre>
cat maggies.dat | fit_coeffs | reconstruct_maggies 0.1 > recmaggies.dat
</pre>
The results would be put into recmaggies.dat. </p>

<p> As I noted above, I have not worked very hard to make the
stand-alone C code or the C library *very* usable, as generally
speaking that would have meant replicating features in IDL and C, and
I wasn't sure how many people would use the pure C versions. If there
is a need to do this, I might be convinced to -- or if YOU do it, we
could include your stuff in the library. </p>

<h3> Using the C Libraries</h3>

<p> Why would you bother incorporating the K-correction code into your
code at all, rather than just calculating the K-corrections once and
reading in the results? Well, perhaps you have to calculate 1/Vmax, in
which for each object you have to check its K-correction at (nearly)
arbitrary redshifts. It is best to calculate the K-corrections on
the fly in these cases, so we provide ways of doing this through a
shared object libary.</p>

<p> For example, the stand-alone C code uses the "libkcorrect.so"
library (in fact, this is *exactly* the same library which is linked
into IDL). If you have this library in your LD_LIBRARY_PATH and you
include the header file "kcorrect.h" (in $KCORRECT_DIR/include), your
own code can call it. The best way to figure out how to use it is to
read the examples in fit_coeffs.c and reconstruct_maggies.c, but I'll try to
explain the essentials here.  </p>

<ul>
<li>
First, the code has to have the basic information about the
templates. You will usually be using the "default" templates in
$KCORRECT_DIR/data/etemplates, so you will have to load in the files:
<pre>
$KCORRECT_DIR/data/etemplates/ematrix.default.dat
$KCORRECT_DIR/data/etemplates/bmatrix.default.dat
$KCORRECT_DIR/data/etemplates/lambda.default.dat
</pre>
These files are in a <a href="ascii.html"> special ASCII format</a>
which can be read into a "double*" variable in C using the routine
k_load_ascii_table. For example:
<pre>
k_load_ascii_table(&bmatrix,&ndim,&sizes,bmatrixfile);
</pre>
loads in a set of data from bmatrixfile. The pointer to the data is
returned in "bmatrix".  The number of dimensions in the data is
returned in "ndim". "sizes" is an array of size ndim giving the size
of each dimension. The information in each of these files is the following:
<ul>
<li> lambda.default.dat: The wavelength scale covered by the templates
(the *edges*, not centers, of all pixels) [NLAMBDA+1]
<li> bmatrix.default.dat: The orthogonal basis spectra spanning the
SED space [NB,NLAMBDA]
<li> ematrix.default.dat: The eigentemplates, expressed in the basis
defined by the bmatrix [NT, NB]
</ul>

<li> Second, it is necessary to read in the filters. The list of filters is
in the directory:
<pre>
$KCORRECT_DIR/data/etemplates/filterlist.default.dat
</pre>
This list is read by the routine "k_load_filters", which assumes all the
filters are in the directory $KCORRECT_DIR/data/filters (or if
KCORRECT_DIR is not set, in the current directory). This routine is
called as:
<pre>
k_load_filters(&filter_n,&filter_lambda,&filter_pass,&maxn,&nk,filterlist);
</pre>
"nk" is the number of filters. "filter_n" is the number of points in
each filter curve, "filter_lambda" is the wavelength scale of each
filter, and "filter_pass" is the response curve of each filter. "maxn"
is the maximum of "filter_n". This sets the indexing of
"filter_lambda" and "filter_pass", so that to get the ith wavelength
of the kth filter you access "filter_lambda[k*maxn+i]".

<li> Third, you have to define the redshift range over which you are
going to define a look-up table. I usually use 0. to 1., to be safe,
with 1000 steps, using the code:
<pre>
zvals=(double *) malloc(nz*sizeof(double));
for(i=0;i<<blah>nz;i++)
  zvals[i]=zmin+(zmax-zmin)*((double)i+0.5)/(double)nz;
</pre>
where nz=1000, zmin=0., and zmax=1. 

<li> Finally, you have to define the look-up table which tabulates the
projection of each basis element in the bmatrix onto each filter, at
each redshift in zvals:
<pre>
rmatrix=(double *) malloc(nz*nb*nk*sizeof(double));
k_create_r(rmatrix,nk,nb,bmatrix,lambda,nl,zvals,nz,filter_n,
           filter_lambda,filter_pass,maxn);
</pre>
One defines "nb" and "nl" based on the "sizes" returned by the
k_load_ascii_table calls described above. 
</ul>

Once this overhead has been taken care of (and it is a significant
amount of time --- a few seconds --- so only do it once!) you can use
the routines "k_fit_coeffs" and "k_reconstruct_maggies". 

<ul>
<li> <b>k_fit_coeffs</b> is called as:
<pre>
k_fit_coeffs(ematrix,nt,zvals,nz,rmatrix,nk,nb,coeffs,galaxy_maggies,
             galaxy_invvar,galaxy_z,ngalaxy);
</pre>
where galaxy_maggies and galaxy_invvar are expressed in maggies. The 
array coeffs should be of the size (nt*ngalaxy), and the coefficients
are returned in it.
<li> <b>k_reconstruct_maggies</b> is called as:
<pre>
k_reconstruct_maggies(ematrix,nt,zvals,nz,rmatrix,nk,nb,coeffs,galaxy_z,
                      reconstruct_maggies,ngalaxy);
</pre>
where reconstruct_maggies are expressed in maggies.
</ul>

<p> Clever people will realize that a photometric redshift estimation
code can easily be constructed from the parts assembled here. Cleverer
people will deduce that in fact this has already been implemented and
<a href="photoz.html"> documented</a> in the distribution here.</P>

<p> As I noted above, I have not worked very hard to make the
stand-alone C code or the C library *very* usable, as generally
speaking that would have meant replicating features in IDL and C, and
I wasn't sure how many people would use the pure C versions. If there
is a need to do this, I might be convinced to -- or if YOU do it, we
could include your stuff in the library. </p>

<h3> A Note on Photometric Errors</h3>

The photometric errors in the SDSS are not dominated by Poisson noise,
which is what is estimated in the parameters "petroCountsErr",
etc. Instead, the errors are dominated by local calibration errors and
other systematic effects, which are poorly known. I usually add errors
of [0.05,0.02,0.02,0.02,0.03] in ugriz in quadrature to the estimated
errors from PHOTO, which makes things considerably better behaved.

<hr> 

<address>
Snail Mail: <a href="../address.html"
>
Michael Blanton</a>;
Email: <a href="mailto:mb144@nyu.edu"> mb144@nyu.edu</a> 
</address>

</BODY>
</HTML>
