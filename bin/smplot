#!/usr/bin/perl

# 
# smrun : perl script to run super-mongo files
#
# MB 11/7/95

chop($cwd = `pwd`);

# analyze options
require 'complete.pl';
require 'flush.pl';
require 'getopts.pl';
&Getopts('f:esnla');

$args{'kcorrect_dir'}=$ENV{'KCORRECT_DIR'};

foreach $arg (@ARGV) {
	if($name eq "") {
		$name=$arg;
	} else {
		if(!($arg eq "")) {
			@argw=split('=',$arg);
#	print "$argw[0] $argw[1]\n";
			if ($argw[1] eq "") {
				$argw[1]=1;
			} 
			$args{$argw[0]}="$argw[1]";
		} 
	}
}

if($args{'title'} eq "") {
	$args{'title'}="\ ";
}

# check what kind of print we want
if (defined $opt_e) {
	$encap = "encap";
} elsif (defined $opt_s) {
	$encap = "smallencap";
} elsif (defined $opt_l) {
	$encap = "landscape";
} else {
	$encap = "";
}

# set .ps name automatically
$theword=$ARGV[0];
@thelist=split(/\./,$theword);
if($thelist[@thelist-1] eq "sm") {
	$thelist[@thelist-1]="ps";
} else {
	$thelist[@thelist]="ps";
}
$autofilename=join('.',@thelist[0..@thelist-1]);

# find list of .ps files in this dir
$currdir=$ENV{'PWD'};
opendir(THISDIR,".");
@files = (grep(-f $_ && -w $_ && /.*\.ps$/, readdir(THISDIR)), $autofilename);
closedir(THISDIR);

# process input file and prepare for sm call
$outfile = ".smtmp";
open(ofp,">$outfile");
$infile = $ARGV[0];
if(-e "$ENV{'KCORRECT_DIR'}/sm/$infile") {
	open(ifp,"<$ENV{'KCORRECT_DIR'}/sm/$infile");
} elsif(-e "$infile") {
	open(ifp,"<$infile");
} else {
	print "Cannot find $infile in . or in $ENV{'KCORRECT_DIR'}/sm\n";
	exit;
}
print ofp "x11$encap\n";
print ofp "define _mbfile \"$currdir/$infile\"\n";
@arglist=%args;
for($i=0;$i<@arglist-1;$i+=2) {
	if($arglist[$i+1] ne "") {
		print ofp "define $arglist[$i] <$arglist[$i+1]>\n";
	} 
}
while(<ifp>) {
	if (!(/^#.*/)) {
		print ofp;
	}
}
close(ifp);
close(ofp);

# if we have a display, call sm, send commands, and wait for user
if ((defined $ENV{'DISPLAY'})&&(!(defined $opt_n))) {
	open(super,"|sm -q -S -v0 -m .smsetup > .smjunk");
	&printflush(super,"execute .smtmp\n");
	$save="n\n";
	if (defined $opt_f) {
  	print "Save as $opt_f? [n] ";
		chop($save = <STDIN>);
	} else {
  	print "Save as $autofilename? [n] ";
		chop($save = <STDIN>);
	}
	close(super);
} else {
	if (defined $opt_f || defined $opt_a) {
		$save="y";
	} else {
  	print "Save as $autofilename? [n] ";
		chop($save = <STDIN>);
	}
}

# if you want to save
if (defined $opt_f) {
  if ($save eq "y") {
    $savefile=$opt_f;
  }
} elsif (defined $opt_a) {
	$savefile=$autofilename;
} else {
  if ($save eq "y") {
    $savefile=$autofilename;
  }
}

if (defined $savefile) {
# process input file and prepare for sm call
  $outfile = ".smtmp";
  open(ofp,">$outfile");
  $infile = $ARGV[0];
	if(-e "$ENV{'KCORRECT_DIR'}/sm/$infile") {
		open(ifp,"<$ENV{'KCORRECT_DIR'}/sm/$infile");
	} elsif(-e "$infile") {
		open(ifp,"<$infile");
	} else {
		print "Cannot find $infile in . or in $ENV{'KCORRECT_DIR'}/sm\n";
		exit;
	}
  print ofp "ps$encap $savefile\n";
	print ofp "define _mbfile \"$currdir/$infile\"\n";
	@arglist=%args;
	for($i=0;$i<@arglist-1;$i+=2) {
		if($arglist[$i+1] ne "") {
			print ofp "define $arglist[$i] <$arglist[$i+1]>\n";
		} 
	}
  while(<ifp>) {
		if (!(/^#.*/)) {
			print ofp;
		}
  }
  close(ifp);
  print ofp "hardcopy\n";
	close(ofp);
		
# call sm, send commands, and wait for user
	open(super,"|sm -q -S -v0 -m .smsetup > .smjunk");
	&printflush(super,"execute .smtmp\n");
	close(super);

# output to user 
	print "File saved as $savefile\n";
}
